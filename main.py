import math  # Импорт стандартного модуля math для математических функций

# Импорт классов и модулей из проекта:
from dto.equation import Equation  # Класс Equation, который инкапсулирует функцию и её строковое представление
from methods.half_division_method import HalfDivisionMethod  # Метод половинного деления для поиска корней
from methods.newton_method import NewtonMethod  # Метод Ньютона для поиска корней
from methods.simple_iterations_method import SimpleIterationsMethod  # Метод простых итераций для поиска корней
from methods.chord_method import ChordMethod  # Метод хорд для поиска корней

import system_of_equation  # Модуль для работы с системами уравнений
import mainboilerplate  # Модуль для взаимодействия с пользователем (выбор функции, метода и ввод данных)

# Словарь, сопоставляющий номер метода с классом, реализующим данный метод
methods = {
    1: HalfDivisionMethod,   # Метод половинного деления
    2: ChordMethod,          # Метод хорд
    3: SimpleIterationsMethod,  # Метод простых итераций
    4: NewtonMethod          # Метод Ньютона
}

# Словарь с предопределёнными функциями, где ключ - номер функции, а значение - объект Equation,
# который содержит как лямбда-функцию для вычислений, так и строковое представление функции для отображения
predefined_functions = {
    1: Equation(lambda x: (-1.38*x**3 - 5.42*x**2 + 2.57*x + 10.95), '-1.38*x^3 - 5.42*x^2 + 2.57*x + 10.95'),
    2: Equation(lambda x: (x**3 - 1.89*x**2 - 2*x + 1.76), 'x^3 - 1.89*x^2 - 2*x + 1.76'),
    # https://cutt.ly/6zNbCha
    3: Equation(lambda x: (x / 2 - 2 * (x + 2.39) ** (1 / 3)), 'x/2 - 2*(x + 2.39)^(1/3)'),
    # https://cutt.ly/MzNdHH5
    4: Equation(lambda x: (-x / 2 + math.e ** x + 5 * math.sin(x)), '-x/2 + e^x + 5*sin(x)'),
}

# Флаг для включения логирования процесса решения (вывод промежуточной информации)
ENABLE_LOGGING = False

# Основной цикл программы, позволяющий многократно решать уравнения/системы
while True:
    # Пользователю предлагается выбрать тип задачи (одиночное уравнение или систему уравнений)
    equation_type = mainboilerplate.choose_equation_type()

    # Если выбран тип 3, выходим из цикла и завершаем программу
    if equation_type == 3:
        break

    # Если выбран режим решения одиночного уравнения:
    if equation_type == 1:
        # Пользователь выбирает одну из предопределённых функций
        function = mainboilerplate.choose_equation(predefined_functions)
        try:
            # Пытаемся построить график выбранной функции на интервале от -100 до 100
            function.draw(-100, 100)
        except Exception as e:
            # Если произошла ошибка при построении графика, выводим сообщение об ошибке
            print('(!) Не удалось построить график функции, ', e)

        # Пользователь выбирает метод для нахождения корня уравнения
        method_number = mainboilerplate.choose_method_number(methods)

        # Цикл для ввода исходных данных (границы, точность, число знаков после запятой)
        while True:
            # Если выбран метод Ньютона (номер 4), запрашиваем специфичные для него данные:
            if method_number == 4:
                left, epsilon, decimal_places = mainboilerplate.read_initial_data_newton()
                right = 0  # Для метода Ньютона правая граница не используется
            else:
                # Для остальных методов запрашиваем левую и правую границы, точность и число знаков после запятой
                left, right, epsilon, decimal_places = mainboilerplate.read_initial_data()

            # Создаём объект выбранного метода, передавая в него функцию и исходные данные
            method = methods[method_number](function, left, right, epsilon, decimal_places, ENABLE_LOGGING)
            try:
                # Выполняем проверку корректности введённых данных и условий применимости метода
                verified, reason = method.check()
            except TypeError as te:
                # Если при вычислении функции произошла ошибка (например, функция не определена на интервале),
                # выводим сообщение об ошибке и просим повторить ввод
                print('(!) Ошибка при вычислении значения функции, возможно она не определена на всем интервале.')
                continue
            # Если проверка не пройдена, выводим сообщение с причиной и завершаем цикл ввода данных
            if not verified:
                print('(!) Введенные исходные данные для метода некорректны: ', reason)
            break  # Выходим из цикла, если данные введены корректно

        try:
            # Пытаемся построить график функции на введённом интервале
            function.draw(left, right)
        except Exception as e:
            # Если график не удалось построить, выводим сообщение об ошибке
            print('(!) Не удалось построить график функции, ', e)

        # Запрос у пользователя имени файла для вывода результата,
        # если строка пуста, результат будет выведен в консоль
        output_file_name = input("Введите имя файла для вывода результата или пустую строку, чтобы вывести в консоль: ")

        try:
            # Если включено логирование, выводим сообщение о начале процесса решения
            if ENABLE_LOGGING:
                print('Процесс решения: ')
            # Запускаем процесс решения уравнения выбранным методом
            result = method.solve()
        except Exception as e:
            # Если произошла ошибка во время решения, выводим сообщение об ошибке
            print(e)
            print('(!) Что-то пошло не так при решении: ', e)
            continue  # Возвращаемся к началу основного цикла, чтобы дать возможность попробовать снова

        # Выводим результат решения (либо в файл, либо в консоль)
        mainboilerplate.print_result(result, output_file_name)

        # Предлагаем пользователю повторить процесс решения уравнения
        if input('\nЕще раз? [y/n] ') != 'y':
            break  # Если пользователь не вводит 'y', выходим из цикла
    else:
        # Если выбран режим решения системы уравнений, вызывается соответствующая функция
        system_of_equation.run()

# Завершаем работу программы, выводя благодарность пользователю
print('Спасибо за использование программы!')
